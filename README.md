# Lab 1 - Multiplication
Алгоритм умножения целых чисел со знаком в дополнительном коде со сдвигом суммы частичных произведений вправо, неподвижным множимым и анализом множителя, начиная с младших разрядов. Реализация представлена на кодах ARM-ассемблера.  
___
### Инструкция для разработчика:
Значение множимого помещается в переменную A, значение множителя помещается в переменную B.  
Переменная С(register R3) выступает как сумматор для этих переменных в соответствии с правилами умножения.  

Если число отрицательное, то перед записью в ячейку переменной его необходимо перевести в дополнительный код. Если число положительное, то никаких преобразований не требуется, так как для положительных чисел прямой и дополнительный код совпадает.  

Для нормальной работы алгоритма переменные А и В должны иметь одинаковую разрядность n, а переменная C, в которой в конце работы алгоритма окажется результат произведения, должна иметь разрядность 2n.  

### Процесс умножения:  

Умножение начинается с анализа множителя. 
1. Первым шагом к крайнему правому разряду приписывается 0. Это необходимо для последующего анализа множителя.   
2. На втором шаге определяется значение двух наименее значимых (правых) бит и вычисляется по ним значение, согласно которому выбирается следующая операция:  
>- Если их разница(от младшего к большему) равна 1, прибавить A к С. Переполнение игнорировать. 
>- Если их разница(от младшего к большему) равна -1, прибавить -А к С. Переполнение игнорировать.
>- Если их разница(от младшего к большему) равна 0, действий не требуется.  

3. Третьим шагом необходимо выполнить арифметический сдвиг значений переменной С на один разряд вправо. При этом продублировать значение знакового регистра. Так как после арифметического сдвига вправо освободится крайний левый разряд, то его необходимо заполнить 1, если до сдвига в нём была единица, и нулём, если до сдвига значение этого разряда было 0. Следует учитывать, что значения, которые были сдвинуты не исчезают и не затираются, а продолжают оставаться в памяти переменной С. Для этого и было необходимо, чтобы переменная С была разрядностью 2n.

4. Следующим шагом нужно вернуться к шагу 2 данного алгоритма, но за наименее значимые биты принимать следующие 2 бита, то есть произвести сдвиг анализатора множителя на 1 разряд влево. К шагу 2 нужно возвращаться до тех пор, пока не будут проанализированы все биты множителя. 

5. В последней итерации, при анализе 7-го и 8-го бита для 8-разрядного регистра, после операции сложения и сдвига, в переменной С уже будет находиться результат умножения. Причём, если крайний левый бит равен 0, то число положительно и уже представлено в прямом коде. А если крайний левый бит равен 1, то число отрицательно и представлено в дополнительном коде, то есть требует перевода в прямой код. После чего работа алгоритма завершается.  

